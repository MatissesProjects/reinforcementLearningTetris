<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris AI v27 - Evolvable Persistence</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: 'Roboto Mono', monospace; background-color: #1a202c; color: #e2e8f0; }
        .game-container canvas { background-color: #000; border: 2px solid #4a5568; border-radius: 0.5rem; }
        .info-panel { background-color: #2d3748; border-radius: 0.5rem; padding: 1rem; font-size: 0.8rem; }
        .info-panel canvas { background-color: #1a202c; border: 1px solid #4a5568; border-radius: 0.25rem; }
        #dna-display, #parent-dna-input { background-color: #1a202c; border: 1px solid #4a5568; font-size: 0.75rem; white-space: pre-wrap; word-wrap: break-word; width: 100%; min-height: 120px; }
        input[type=range] { -webkit-appearance: none; width: 100%; height: 8px; background: #4a5568; border-radius: 5px; outline: none; opacity: 0.7; transition: opacity .2s; }
        input[type=range]:hover { opacity: 1; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; background: #a0aec0; cursor: pointer; border-radius: 50%; }
        input[type=range]::-moz-range-thumb { width: 18px; height: 18px; background: #a0aec0; cursor: pointer; border-radius: 50%; }
        #game-instances-container { display: flex; flex-wrap: wrap; justify-content: center; gap: 2rem; }
        .instance-wrapper { flex-grow: 1; min-width: 550px; max-width: 600px; }
    </style>
</head>
<body class="p-4 sm:p-8">

    <div class="max-w-screen-2xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-3xl sm:text-4xl font-bold text-white">Tetris AI Training Environment</h1>
            <p class="text-gray-400 mt-2">Dueling DQN Gating Network + Evolvable Persistence</p>
        </header>

        <div id="main-controls" class="text-center mb-8 bg-gray-800 p-4 rounded-lg shadow-lg">
             <h2 class="text-xl font-bold mb-4">Master Controls</h2>
            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                 <button id="start-all-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">Start All</button>
                 <button id="stop-all-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg">Stop All</button>
                <div class="flex items-center justify-center">
                    <input type="checkbox" id="human-player-checkbox" class="h-5 w-5 rounded">
                    <label for="human-player-checkbox" class="ml-2">Human Player</label>
                </div>
                <div class="flex items-center justify-center">
                    <input type="checkbox" id="ai-enabled-checkbox" class="h-5 w-5 rounded" checked>
                    <label for="ai-enabled-checkbox" class="ml-2">Enable AI</label>
                </div>
            </div>
            
             <p id="seed-display" class="text-xs text-gray-500 mb-4"></p>
             
             <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                    <h3 class="text-lg font-bold mb-2">Population Controls</h3>
                    <div class="flex justify-between items-center mb-4">
                        <label for="num-instances" class="text-right pr-2 py-1">Instances:</label>
                        <input type="number" id="num-instances" value="4" min="1" max="12" class="bg-gray-700 text-white rounded px-2 py-1 w-24 text-center">
                        <label class="text-right pr-2 py-1">Generation:</label>
                        <span id="generation-display" class="font-bold text-lg text-teal-300">0</span>
                    </div>
                    <button id="generate-instances-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg w-full mt-4">Generate New Population</button>
                    <button id="permutate-btn" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded-lg w-full mt-2">Generate from Parent DNA</button>
                    <textarea id="parent-dna-input" class="mt-4 p-2 rounded-md w-full" placeholder="Paste parent agent's DNA here..."></textarea>
                    <button id="extract-dna-btn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg w-full mt-2">Extract Best Agent's DNA</button>
                    <textarea id="dna-display" class="mt-2 p-2 rounded-md text-left hidden" readonly></textarea>
                </div>
                 <div>
                     <h3 class="text-lg font-bold mb-2">AI Parameters</h3>
                     <div class="space-y-3 text-sm text-left">
                        <h4 class="font-bold mt-4 border-b border-gray-600">Live Parameters</h4>
                        <div>
                             <label for="lookahead-depth">Lookahead Depth: <span id="lookahead-depth-value">3</span></label>
                             <input type="range" id="lookahead-depth" min="1" max="5" step="1" value="3">
                        </div>
                        <div>
                            <label for="beam-width">Beam Width: <span id="beam-width-value">5</span></label>
                            <input type="range" id="beam-width" min="1" max="10" step="1" value="5">
                        </div>
                         <div>
                            <label for="game-speed">AI Speed: <span id="game-speed-value">Normal</span></label>
                            <input type="range" id="game-speed" min="0" max="1000" step="10" value="500">
                        </div>
                        <h4 class="font-bold mt-4 border-b border-gray-600">Evolution & Learning Parameters</h4>
                        <div class="flex justify-between items-center">
                            <label for="warmup-generations">Gating Warm-up Gens:</label>
                            <input type="number" id="warmup-generations" value="5" min="0" max="50" class="bg-gray-700 text-white rounded px-2 py-1 w-24 text-center">
                        </div>
                        <div class="flex justify-between items-center">
                            <label for="curriculum-generations">Heuristic-Only Gens:</label>
                            <input type="number" id="curriculum-generations" value="10" min="0" max="50" class="bg-gray-700 text-white rounded px-2 py-1 w-24 text-center">
                        </div>
                        <div>
                             <label for="learning-rate">Gating Network Learning Rate (α): <span id="learning-rate-value">0.01</span></label>
                             <input type="range" id="learning-rate" min="0" max="0.1" step="0.001" value="0.01">
                        </div>
                        <div>
                             <label for="action-exploration-rate">Expert Exploration Rate (ε): <span id="action-exploration-rate-value">0.10</span></label>
                             <input type="range" id="action-exploration-rate" min="0" max="1.0" step="0.01" value="0.1">
                        </div>
                        <div>
                            <label for="discount-factor">Discount Factor (γ): <span id="discount-factor-value">0.95</span></label>
                            <input type="range" id="discount-factor" min="0.5" max="1.0" step="0.01" value="0.95">
                        </div>
                        <div>
                            <label for="mutation-rate">Weight Mutation Rate: <span id="mutation-rate-value">0.20</span></label>
                            <input type="range" id="mutation-rate" min="0.01" max="1.0" step="0.01" value="0.2">
                        </div>
                        <div>
                            <label for="mutation-amount">Weight Mutation Amount: <span id="mutation-amount-value">0.50</span></label>
                            <input type="range" id="mutation-amount" min="0.01" max="1.0" step="0.01" value="0.5">
                        </div>
                         <div>
                             <label for="topology-mutation-rate">Topology Mutation Rate: <span id="topology-mutation-rate-value">0.20</span></label>
                             <input type="range" id="topology-mutation-rate" min="0" max="0.5" step="0.01" value="0.2">
                        </div>
                     </div>
                 </div>
             </div>
        </div>

        <div id="performance-container" class="my-8 bg-gray-800 p-4 rounded-lg shadow-lg">
             <button id="toggle-chart-btn" class="w-full text-left font-bold text-lg mb-2">Performance History (Click to Toggle)</button>
             <div id="chart-wrapper" class="hidden">
                 <canvas id="performance-chart"></canvas>
             </div>
        </div>

        <div id="game-instances-container">
             </div>
    </div>
    
    <script>
    // --- GAME CONSTANTS AND CORE LOGIC ---
    const COLS=10;const ROWS=20;const HIDDEN_ROWS=20;const BLOCK_SIZE=30;const COLORS={T:"#a000f0",I:"#00f0f0",O:"#f0f000",L:"#f0a000",J:"#0000f0",S:"#00f000",Z:"#f00000",GHOST:"rgba(255,255,255,0.2)"};const SHAPES={I:[[[0,0,0,0],[2,2,2,2],[0,0,0,0],[0,0,0,0]],[[0,0,2,0],[0,0,2,0],[0,0,2,0],[0,0,2,0]],[[0,0,0,0],[0,0,0,0],[2,2,2,2],[0,0,0,0]],[[0,2,0,0],[0,2,0,0],[0,2,0,0],[0,2,0,0]]],J:[[[5,0,0],[5,5,5],[0,0,0]],[[0,5,5],[0,5,0],[0,5,0]],[[0,0,0],[5,5,5],[0,0,5]],[[0,5,0],[0,5,0],[5,5,0]]],L:[[[0,0,4],[4,4,4],[0,0,0]],[[0,4,0],[0,4,0],[0,4,4]],[[0,0,0],[4,4,4],[4,0,0]],[[4,4,0],[0,4,0],[0,4,0]]],O:[[[0,3,3,0],[0,3,3,0],[0,0,0,0]]],S:[[[0,6,6],[6,6,0],[0,0,0]],[[0,6,0],[0,6,6],[0,0,6]],[[0,0,0],[0,6,6],[6,6,0]],[[6,0,0],[6,6,0],[0,6,0]]],T:[[[0,1,0],[1,1,1],[0,0,0]],[[0,1,0],[0,1,1],[0,1,0]],[[0,0,0],[1,1,1],[0,1,0]],[[0,1,0],[1,1,0],[0,1,0]]],Z:[[[7,7,0],[0,7,7],[0,0,0]],[[0,0,7],[0,7,7],[0,7,0]],[[0,0,0],[7,7,0],[0,7,7]],[[0,7,0],[7,7,0],[7,0,0]]]};const KICK_DATA={JLSTZ:[[[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],[[0,0],[1,0],[1,-1],[0,2],[1,2]],[[0,0],[1,0],[1,-1],[0,2],[1,2]],[[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],[[0,0],[1,0],[1,1],[0,-2],[1,-2]],[[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],[[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],[[0,0],[1,0],[1,1],[0,-2],[1,-2]]],I:[[[0,0],[-2,0],[1,0],[-2,-1],[1,2]],[[0,0],[2,0],[-1,0],[2,1],[-1,-2]],[[0,0],[-1,0],[2,0],[-1,2],[2,-1]],[[0,0],[1,0],[-2,0],[1,-2],[-2,1]],[[0,0],[2,0],[-1,0],[2,1],[-1,-2]],[[0,0],[-2,0],[1,0],[-2,-1],[1,2]],[[0,0],[1,0],[-2,0],[1,-2],[-2,1]],[[0,0],[-1,0],[2,0],[-1,2],[2,-1]]]};
    const PIECE_MAP={1:"T",2:"I",3:"O",4:"L",5:"J",6:"S",7:"Z"};const PIECE_KEYS=Object.keys(SHAPES);
    const DAS=10,ARR=0,LOCK_DELAY_DURATION=500;
    class SeededRandom{constructor(e){this.seed=e}next(){return this.seed=(9301*this.seed+49297)%233280,this.seed/233280}}
    
    class TetrisGame{
        constructor(e,t,s){this.id=t;this.container=e;this.rng=new SeededRandom(s);this.lastTime=0;this.agent=null;this.initUI();this.reset();}
        initUI() {
            this.container.innerHTML = `
                <h2 class="text-xl font-bold mb-4 text-center w-full">Agent ${this.id}</h2>
                <div class="flex flex-col sm:flex-row gap-4 w-full items-start justify-center">
                    <div class="info-panel flex-shrink-0 w-full sm:w-40 text-center">
                        <div class="mb-4">
                            <h3 class="text-lg font-bold">HOLD</h3>
                            <div class="h-24 flex items-center justify-center mt-2">
                                <canvas id="hold-canvas-${this.id}" width="80" height="80"></canvas>
                            </div>
                        </div>
                        <div>
                            <h3 class="text-lg font-bold mb-2">STATS</h3>
                            <p>Score: <span id="score-${this.id}">0</span></p>
                            <p>Lines: <span id="lines-${this.id}">0</span></p>
                            <p>Level: <span id="level-${this.id}">1</span></p>
                            <p>Pieces: <span id="pieces-${this.id}">0</span></p>
                            <p>Combo: <span id="combo-${this.id}">0</span></p>
                            <p>Max Combo: <span id="max-combo-${this.id}">0</span></p>
                            <p>T-Spins: <span id="t-spins-${this.id}">0</span></p>
                            <p>Tetrises: <span id="tetrises-${this.id}">0</span></p>
                            <p>B2B: <span id="b2b-${this.id}">0</span></p>
                            <div id="agent-dna-display-${this.id}" class="mt-2 text-left"></div>
                        </div>
                        <button id="reset-btn-${this.id}" class="reset-btn mt-4 bg-gray-600 hover:bg-gray-700 text-white font-bold py-1 px-2 rounded">Reset</button>
                    </div>
                    <div class="game-container relative flex-grow">
                        <canvas id="game-canvas-${this.id}" width="${10 * BLOCK_SIZE}" height="${20 * BLOCK_SIZE}"></canvas>
                        <div id="game-over-${this.id}" class="absolute inset-0 bg-black/75 flex items-center justify-center text-2xl font-bold text-red-500" style="display: none;">GAME OVER</div>
                    </div>
                    <div class="info-panel flex-shrink-0 w-full sm:w-40 text-center">
                        <h3 class="text-lg font-bold">NEXT</h3>
                        <div id="next-queue-${this.id}" class="flex flex-col items-center gap-2 mt-2"></div>
                    </div>
                </div>`;
            this.canvas=document.getElementById(`game-canvas-${this.id}`);this.ctx=this.canvas.getContext("2d");this.ctx.scale(BLOCK_SIZE,BLOCK_SIZE);this.holdCtx=document.getElementById(`hold-canvas-${this.id}`).getContext("2d");this.nextQueueContainer=document.getElementById(`next-queue-${this.id}`);this.nextCanvases=[];for(let e=0;e<5;e++){const t=document.createElement("canvas");t.width=80,t.height=80,this.nextQueueContainer.appendChild(t),this.nextCanvases.push(t.getContext("2d"))}this.scoreEl=document.getElementById(`score-${this.id}`);this.linesEl=document.getElementById(`lines-${this.id}`);this.levelEl=document.getElementById(`level-${this.id}`);this.comboEl=document.getElementById(`combo-${this.id}`);this.b2bEl=document.getElementById(`b2b-${this.id}`);this.maxComboEl=document.getElementById(`max-combo-${this.id}`);this.tSpinsEl=document.getElementById(`t-spins-${this.id}`);this.tetrisesEl=document.getElementById(`tetrises-${this.id}`);this.dnaDisplayEl=document.getElementById(`agent-dna-display-${this.id}`);this.gameOverEl=document.getElementById(`game-over-${this.id}`);this.piecesEl=document.getElementById(`pieces-${this.id}`);document.getElementById(`reset-btn-${this.id}`).addEventListener("click",()=>this.reset());document.querySelector(`#instance-wrapper-${this.id} h2`).textContent=`Agent ${this.id}`}
        reset(){this.isRunning=!1,this.isGameOver=!1,this.score=0,this.linesCleared=0,this.level=1,this.combo=0,this.maxCombo=0,this.tSpins=0,this.b2b=0,this.tetrisesCleared=0,this.finesseMoves=0,this.startTime=Date.now(),this.dropCounter=0,this.dasCounter=0,this.arrCounter=0,this.leftHeld=!1,this.rightHeld=!1,this.softDropActive=!1,this.lockDelayTimer=0,this.isTouchingFloor=!1,this.lastMoveWasRotation=!1,this.grid=this.createGrid(COLS,ROWS+HIDDEN_ROWS),this.pieceQueue=[],this.fillQueue(),this.spawnNewPiece(),this.holdPiece=null,this.canHold=!0,this.piecesPlaced=0,this.updateStats(),this.gameOverEl.style.display="none"; const wrapper = document.getElementById(`instance-wrapper-${this.id}`); if (wrapper) { wrapper.classList.remove('opacity-50'); } }
        createGrid(e,t){return Array.from({length:t},()=>Array(e).fill(0))}fillQueue(){const e=[...PIECE_KEYS];while(e.length){const t=e.splice(Math.floor(this.rng.next()*e.length),1)[0];this.pieceQueue.push(t)}}
        spawnNewPiece(e=null){if(this.isGameOver)return;e||(this.pieceQueue.length<7&&this.fillQueue(),e=this.pieceQueue.shift()),this.activePiece={type:e,rotation:0,x:3,y:18,finesse:0},"O"===e&&(this.activePiece.x=4),"I"===e&&(this.activePiece.y=17),this.activePiece.shape=SHAPES[this.activePiece.type][this.activePiece.rotation],this.isTouchingFloor=!1,this.lastMoveWasRotation=!1,this.checkCollision(this.activePiece.shape,this.activePiece.x,this.activePiece.y)&&this.gameOver()}
        checkCollision(e,t,s,i=this.grid){if(!e||!e.length)return!0;for(let r=0;r<e.length;r++)for(let o=0;o<e[r].length;o++)if(0!==e[r][o]){const n=t+o,l=s+r;if(n<0||n>=COLS||l<0||l>=ROWS+HIDDEN_ROWS||i[l]&&0!==i[l][n])return!0}return!1}
        lockPiece() {
            const piece = this.activePiece;
            if (!piece || piece.y < 0) return;
            this.piecesPlaced++; 
            piece.shape.forEach((row, rowIndex) => { row.forEach((value, colIndex) => { if (value !== 0) { const boardY = piece.y + rowIndex; const boardX = piece.x + colIndex; if (boardY >= 0 && boardY < this.grid.length && this.grid[boardY]) { this.grid[boardY][boardX] = value; } } }); });
            const spinInfo = this.lastMoveWasRotation ? this.checkSpin(piece) : { isSpin: false, isMini: false };
            let clearedRows = this.clearLines();
            if(spinInfo.isSpin && piece.type === 'T' && clearedRows.length > 0) this.tSpins++;
            if (clearedRows.length > 0) {
                if (clearedRows.length === 4) this.tetrisesCleared++;
                let score = 0; const isDifficult = clearedRows.length >= 4 || spinInfo.isSpin;
                if (spinInfo.isSpin) { score = spinInfo.isMini ? { 1: 200, 2: 400 }[clearedRows.length] || 100 : { 1: 800, 2: 1200, 3: 1600 }[clearedRows.length] || 400; } else { score = { 1: 100, 2: 300, 3: 500, 4: 800 }[clearedRows.length] || 0; }
                if(this.b2b > 0 && isDifficult) score = Math.floor(1.5 * score);
                this.score += score * this.level; this.combo++; this.maxCombo = Math.max(this.maxCombo, this.combo); this.score += 50 * this.combo * this.level;
                isDifficult ? this.b2b++ : this.b2b = 0;
                this.linesCleared += clearedRows.length; this.level = Math.floor(this.linesCleared / 10) + 1;
            } else { this.combo = 0; }
            if (this.grid.slice(HIDDEN_ROWS).every(r => r.every(c => c === 0))) this.score += 3500 * this.level;
            this.spawnNewPiece(); this.canHold = !0; this.updateStats();
        }
        checkSpin(e, grid = this.grid) {
            if (!e?.type || "O" === e.type || e.y < 0) return { isSpin: false, isMini: false };
            const t = e.x + 1, s = e.y + 1; let i = 0, r = 0;
            const o = [[s - 1, t - 1], [s - 1, t + 1], [s + 1, t + 1], [s + 1, t - 1]];
            o.forEach(([y, x]) => { if (y >= 0 && grid[y]?.[x] > 0) i++; });
            if (i < 3) return { isSpin: false, isMini: false };
            const n = [[s - 1, t], [s, t + 1], [s + 1, t], [s, t - 1]][e.rotation];
            o.forEach(([y, x], idx) => { if (!(y === n[0] && x === n[1])) { if (y >= 0 && grid[y]?.[x] > 0) r++; } });
            return { isSpin: true, isMini: r < 2 };
        }
        clearLines(){let t=[];for(let s=this.grid.length-1;s>=0;s--)this.grid[s].every(e=>0!==e)&&t.push(s);if(t.length>0){for(const i of t)this.grid.splice(i,1);for(let i=0;i<t.length;i++)this.grid.unshift(new Array(COLS).fill(0));}return t}
        move(e){if(!this.activePiece||this.checkCollision(this.activePiece.shape,this.activePiece.x+e,this.activePiece.y))return!1;this.activePiece.x+=e,this.activePiece.finesse++,this.resetLockDelay(),this.lastMoveWasRotation=!1,!0}
        rotate(e=1){const t=this.activePiece;if(!t||"O"===t.type)return!1;const s=t.rotation,i=(s+e+4)%4,r="I"===t.type?KICK_DATA.I:KICK_DATA.JLSTZ,o=1===e?2*s:2*i+1;for(const[n,l]of r[o])if(!this.checkCollision(SHAPES[t.type][i],t.x+n,t.y-l))return t.x+=n,t.y-=l,t.rotation=i,t.shape=SHAPES[t.type][i],t.finesse++,this.resetLockDelay(),this.lastMoveWasRotation=!0,!0;return!1}
        resetLockDelay(){if(this.isTouchingFloor)this.lockDelayTimer=LOCK_DELAY_DURATION}
        drop(soft = false){
            if (!this.activePiece || this.checkCollision(this.activePiece.shape, this.activePiece.x, this.activePiece.y + 1)) {
                this.isTouchingFloor = true;
                return;
            }
            this.activePiece.y++;
            if (soft) this.score++;
            this.isTouchingFloor = false;
            this.lockDelayTimer = LOCK_DELAY_DURATION;
        }
        hardDrop(){if(!this.activePiece)return;let cellsDropped=0;while(!this.checkCollision(this.activePiece.shape,this.activePiece.x,this.activePiece.y+1)){this.activePiece.y++,cellsDropped++};this.score+=2*cellsDropped;this.lockPiece()}
        hold(){if(!this.canHold||!this.activePiece)return;const heldType=this.holdPiece?this.holdPiece.type:null;this.holdPiece={type:this.activePiece.type};this.spawnNewPiece(heldType),this.canHold=!1,this.draw()}
        update(e){
            if(!this.isRunning||this.isGameOver)return;
            this.handleHorizontalMovement();

            const gravity = 1000 / this.level;
            const dropInterval = this.softDropActive ? Math.min(50, gravity) : gravity;

            this.dropCounter += e;
            if (this.dropCounter >= dropInterval) {
                this.dropCounter = 0;
                this.drop();
            }

            if (this.isTouchingFloor) {
                this.lockDelayTimer -= e;
                if (this.lockDelayTimer <= 0) {
                    this.lockPiece();
                }
            }
            this.draw(); 
            if(this.agent) {this.agent.updateAgentDisplay();}
        }
        handleHorizontalMovement(){if(this.leftHeld===this.rightHeld){this.dasCounter=0}else{this.dasCounter++;if(this.dasCounter>DAS){this.arrCounter++;if(this.arrCounter>=ARR){this.arrCounter=0;this.move(this.rightHeld?1:-1)}}}}
        handleKeyDown(e){if(this.isGameOver)return;const t=["ArrowLeft","ArrowRight","ArrowDown","ArrowUp","x","X","z","Z"," ","Shift","c","C"];t.includes(e.key)&&e.preventDefault();switch(e.key){case"ArrowLeft":this.leftHeld||(this.move(-1),this.dasCounter=0),this.leftHeld=!0;break;case"ArrowRight":this.rightHeld||(this.move(1),this.dasCounter=0),this.rightHeld=!0;break;case"ArrowDown":this.softDropActive=!0,this.resetLockDelay();break;case"ArrowUp":case"x":case"X":this.rotate(1);break;case"z":case"Z":this.rotate(-1);break;case" ":this.hardDrop();break;case"Shift":case"c":case"C":this.hold()}}
        handleKeyUp(e){switch(e.key){case"ArrowLeft":this.leftHeld=!1;break;case"ArrowRight":this.rightHeld=!1;break;case"ArrowDown":this.softDropActive=!1}}
        draw(){this.ctx.fillStyle="#000",this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height);this.drawMatrix(this.grid,0,-HIDDEN_ROWS,this.ctx);this.drawGhostPiece();this.activePiece&&this.drawMatrix(this.activePiece.shape,this.activePiece.x,this.activePiece.y-HIDDEN_ROWS,this.ctx,this.activePiece.type);this.drawHoldPiece();this.drawNextQueue()}
        drawMatrix(e,t,s,i,r){e.forEach((e,o)=>e.forEach((n,l)=>{if(n!==0){i.fillStyle=r?COLORS[r]:COLORS[PIECE_MAP[n]];i.fillRect(l+t,o+s,1,1)}}))}
        drawGhostPiece(){if(!this.activePiece)return;const e={...this.activePiece};for(;!this.checkCollision(e.shape,e.x,e.y+1);)e.y++;this.ctx.globalAlpha=.3;this.drawMatrix(e.shape,e.x,e.y-HIDDEN_ROWS,this.ctx,this.activePiece.type),this.ctx.globalAlpha=1}
        drawPieceInPreview(e,t){e.clearRect(0,0,80,80);if(t){const s=SHAPES[t.type][0],i="I"===t.type||"O"===t.type?18:20,r=s[0].length*i,o=s.length*i,n=(80-r)/2,l=(80-o)/2;e.fillStyle=COLORS[t.type],s.forEach((t,s)=>t.forEach((r,o)=>{r&&e.fillRect(n+o*i,l+s*i,i-1,i-1)}))}}
        drawHoldPiece(){this.drawPieceInPreview(this.holdCtx,this.holdPiece)}drawNextQueue(){this.nextCanvases.forEach((e,t)=>{const s=this.pieceQueue[t];s?this.drawPieceInPreview(e,{type:s}):e.clearRect(0,0,80,80)})}
        updateStats(){this.scoreEl.textContent=this.score;this.linesEl.textContent=this.linesCleared;this.levelEl.textContent=this.level;this.comboEl.textContent=this.combo;this.b2bEl.textContent=this.b2b;this.maxComboEl.textContent=this.maxCombo;this.tSpinsEl.textContent=this.tSpins;this.tetrisesEl.textContent=this.tetrisesCleared;if(this.piecesEl)this.piecesEl.textContent=this.piecesPlaced;}
        gameOver(){
            this.isRunning=!1,this.isGameOver=!0,this.activePiece=null,this.gameOverEl.style.display="flex";
            if (this.agent) { this.agent.finalFitness = this.agent.calculateFitness(this); }
            console.log(`Game ${this.id} Over! Final Score: ${this.score}`);
            setTimeout(checkAllGameOver, 100);
        }
        start(){if(this.isGameOver)this.reset();if(!this.isRunning){this.isRunning=!0,this.lastTime=0,requestAnimationFrame(this.gameLoop.bind(this))}}stop(){this.isRunning=!1}
        gameLoop(e){if(this.isRunning){const t=e-(this.lastTime||e);this.lastTime=e,this.update(t),requestAnimationFrame(this.gameLoop.bind(this))}}
    }
    
    // --- NEURAL NETWORK & AGENT CLASSES ---
    class Network {
        constructor(layers) { this.layers = layers; }
        static feedForward(inputs, network) {
            let currentOutputs = inputs;
            for (const layer of network.layers) {
                currentOutputs = layer.feedForward(currentOutputs);
            }
            return currentOutputs;
        }
        static getDNA(network) {
            const dna = { layers: [] };
            for(const layer of network.layers) dna.layers.push(layer.getDNA());
            return dna;
        }
        static loadDNA(network, dna) {
            if(!dna || !dna.layers) return;
            for(let i=0; i < network.layers.length; i++) {
                if(network.layers[i] && dna.layers[i]) {
                    network.layers[i].loadDNA(dna.layers[i]);
                }
            }
        }
        static mutate(network, mutationRate, mutationAmount) {
            for(const layer of network.layers) layer.mutate(mutationRate, mutationAmount);
        }
    }
    
    class DuelingNetwork {
        constructor(commonLayers, valueStream, advantageStream) {
            this.common = new Network(commonLayers);
            this.value = new Network(valueStream);
            this.advantage = new Network(advantageStream);
        }

        feedForward(inputs) {
            const commonOutput = Network.feedForward(inputs, this.common);
            const value = Network.feedForward(commonOutput, this.value)[0];
            const advantages = Network.feedForward(commonOutput, this.advantage);
            const meanAdvantage = advantages.reduce((sum, a) => sum + a, 0) / advantages.length;
            const qValues = advantages.map(a => value + (a - meanAdvantage));
            return qValues;
        }

        getDNA() {
            return {
                commonDNA: Network.getDNA(this.common),
                valueDNA: Network.getDNA(this.value),
                advantageDNA: Network.getDNA(this.advantage)
            };
        }
        loadDNA(dna) {
            if(dna.commonDNA) Network.loadDNA(this.common, dna.commonDNA);
            if(dna.valueDNA) Network.loadDNA(this.value, dna.valueDNA);
            if(dna.advantageDNA) Network.loadDNA(this.advantage, dna.advantageDNA);
        }
        mutate(rate, amount) {
            Network.mutate(this.common, rate, amount);
            Network.mutate(this.value, rate, amount);
            Network.mutate(this.advantage, rate, amount);
        }
    }

    class ConvLayer {
        constructor(inputShape, kernelSize, numFilters) {
            this.type = 'conv'; this.inputShape = inputShape; this.kernelSize = kernelSize; this.numFilters = numFilters;
            this.outputShape = { rows: inputShape.rows - kernelSize + 1, cols: inputShape.cols - kernelSize + 1 };
            this.filters = Array.from({length: numFilters}, () => Array.from({length: kernelSize}, () => new Array(kernelSize).fill(0).map(() => Math.random() * 2 - 1)));
            this.biases = new Array(numFilters).fill(0).map(() => Math.random() * 2 - 1);
        }
        feedForward(grid) {
            const relu = x => Math.max(0, x);
            const output = [];
            for (let f = 0; f < this.numFilters; f++) {
                const filter = this.filters[f]; const bias = this.biases[f];
                for (let r = 0; r < this.outputShape.rows; r++) {
                    for (let c = 0; c < this.outputShape.cols; c++) {
                        let sum = 0;
                        for (let kr = 0; kr < this.kernelSize; kr++) for (let kc = 0; kc < this.kernelSize; kc++) sum += (grid[r+kr]?.[c+kc] > 0 ? 1 : 0) * filter[kr][kc];
                        output.push(relu(sum + bias));
                    }
                }
            }
            return output;
        }
        getDNA() { return { type: this.type, weights: this.filters.map(f => f.flat()).flat(), biases: [...this.biases] }; }
        loadDNA(dna) {
            if(!dna?.weights || !dna.biases) return;
            let w_i = 0;
            for(let f=0; f < this.numFilters; f++) for(let r=0; r < this.kernelSize; r++) for(let c=0; c < this.kernelSize; c++) if(dna.weights[w_i] !== undefined) this.filters[f][r][c] = dna.weights[w_i++];
            for(let i=0; i < this.biases.length; i++) if(dna.biases[i] !== undefined) this.biases[i] = dna.biases[i];
        }
        mutate(rate, amount) {
            for(let f=0; f < this.numFilters; f++) for(let r=0; r < this.kernelSize; r++) for(let c=0; c < this.kernelSize; c++) if(Math.random() < rate) this.filters[f][r][c] += (Math.random() * 2 - 1) * amount;
            for(let i=0; i < this.biases.length; i++) if(Math.random() < rate) this.biases[i] += (Math.random() * 2 - 1) * amount;
        }
    }

    class FlattenLayer {
        constructor() { this.type = 'flatten'; }
        feedForward(inputs) { return inputs.flat(); }
        getDNA() { return { type: this.type }; }
        loadDNA(dna) {}
        mutate(rate, amount) {}
    }

    class DenseLayer {
        constructor(inputCount, outputCount, activation = Math.tanh) {
            this.type = 'dense'; this.inputCount = inputCount; this.outputCount = outputCount; this.activation = activation;
            this.weights = Array.from({length: inputCount}, () => new Array(outputCount).fill(0).map(() => (Math.random() * 2 - 1) * Math.sqrt(1/inputCount) ));
            this.biases = new Array(outputCount).fill(0);
        }
        feedForward(inputs) {
            const outputs = new Array(this.outputCount);
            for (let i = 0; i < this.outputCount; i++) {
                let sum = 0;
                for (let j = 0; j < this.inputCount; j++) sum += inputs[j] * this.weights[j][i];
                outputs[i] = this.activation(sum + this.biases[i]);
            }
            return outputs;
        }
        getDNA() { return { type: this.type, weights: this.weights.flat(), biases: [...this.biases] }; }
        loadDNA(dna) {
            if(!dna?.weights || !dna.biases) return;
            let w_i = 0, b_i = 0;
            for(let i=0; i<this.inputCount; i++) for(let j=0; j<this.outputCount; j++) if(dna.weights[w_i] !== undefined) this.weights[i][j] = dna.weights[w_i++];
            for(let i=0; i<this.outputCount; i++) if(dna.biases[b_i] !== undefined) this.biases[i] = dna.biases[b_i++];
        }
        mutate(rate, amount) {
            for(let i=0; i<this.inputCount; i++) for(let j=0; j<this.outputCount; j++) if(Math.random() < rate) this.weights[i][j] += (Math.random() * 2 - 1) * amount;
            for(let i=0; i<this.outputCount; i++) if(Math.random() < rate) this.biases[i] += (Math.random() * 2 - 1) * amount;
        }
    }

    class Agent {
        constructor(game, expertParentDNA = null, globalGatingDNA = null, shouldMutateExperts = true, generation = 0) {
            this.game = game;
            this.generation = generation;
            this.thinkTimeout = null; this.isThinking = false; this.finalFitness = 0; this.previousFeatures = null;
            
            this.expertTypes = ['GENERALIST', 'T_SPIN', 'COMBO', 'DOWNSTACK', 'ALL_CLEAR'];
            this.expertDNA = expertParentDNA ? JSON.parse(JSON.stringify(expertParentDNA)) : this.getInitialExpertDNA();
            this.gatingDNA = globalGatingDNA ? JSON.parse(JSON.stringify(globalGatingDNA)) : this.getInitialGatingDNA();
            
            this.currentExpert = 'GENERALIST';
            this.expertStepsRemaining = 0; 
            this.hasMadeFirstSwitch = false;

            const convOutRows = (ROWS + HIDDEN_ROWS) - 5 + 1;
            const convOutCols = COLS - 5 + 1;
            const flattenedSize = convOutRows * convOutCols * 4;

            this.gatingNetwork = new DuelingNetwork(
                [new ConvLayer({rows: ROWS+HIDDEN_ROWS, cols: COLS}, 5, 4), new FlattenLayer()],
                [new DenseLayer(flattenedSize, 128, Math.tanh), new DenseLayer(128, 64, Math.tanh), new DenseLayer(64, 1, x=>x)],
                [new DenseLayer(flattenedSize, 128, Math.tanh), new DenseLayer(128, 64, Math.tanh), new DenseLayer(64, this.expertTypes.length, x=>x)]
            );
            if(this.gatingDNA.gatingNetworkDNA) {
                this.gatingNetwork.loadDNA(this.gatingDNA.gatingNetworkDNA);
            }

            this.expertBrains = {};
            const featureCount = this.getBoardFeatures(this.game.grid, true).length;
            for (const expert of this.expertTypes) {
                const expertDna = this.expertDNA.expertDna[expert];
                if (!expertDna) { console.error(`DNA for expert "${expert}" not found.`); continue; }
                const weightCount = Object.keys(expertDna.weights).length;

                this.expertBrains[expert] = new Network([
                    new DenseLayer(featureCount, 48, Math.tanh),
                    new DenseLayer(48, 24, Math.tanh),
                    new DenseLayer(24, weightCount, x => x)
                ]);
                if (expertDna.networkDNA) {
                    Network.loadDNA(this.expertBrains[expert], expertDna.networkDNA);
                }
            }
            
            if (shouldMutateExperts) this.mutateExperts();
        }
        
        getInitialGatingDNA() { return { exploration_biases: [0,0,0,0,0] }; }
        // --- EVOLVABLE PERSISTENCE: Add persistence back to DNA with low starting values ---
        getInitialExpertDNA() {
             const baseWeights = {
                aggregateHeight: -0.51, maxHeight: -0.2, holes: -10.0, coveredHoles: -15.0,
                bumpiness: -0.35, wells: -0.72, rowTransitions: -0.1, columnTransitions: -0.1,
                spinOpportunities: 0, pieceCount: 0, overhangs: -2.0, 
                deepestWell: 0, imminentClears: 0, dangerZonePenalty: 0, 
                heightStandardDeviation: 0, spirePenalty: -5.0,
                linesCleared: 1, combo: 3, b2b: 4, finessePenalty: -0.15, 
                spinExecutionBonus: 20, tetrisBonus: 8.0
            };

            const generalistWeights = { ...baseWeights, bumpiness: -0.5, imminentClears: 0.5, dangerZonePenalty: -20.0, heightStandardDeviation: -2.5, spirePenalty: -10.0, deepestWell: 5.0 };
            const tSpinWeights = { ...baseWeights, spinOpportunities: 8.0, b2b: 6.0, spirePenalty: -5.0, spinExecutionBonus: 40.0 };
            const comboWeights = { ...baseWeights, aggregateHeight: -0.1, linesCleared: -0.5, combo: 8.0, heightStandardDeviation: -1.2, spirePenalty: -4.0 };
            const downstackWeights = { ...baseWeights, aggregateHeight: -4.0, holes: -8.0, coveredHoles: -20.0, linesCleared: 8.0, combo: -1.0, dangerZonePenalty: -10.0, deepestWell: -5.0 };
            const allClearWeights = { ...baseWeights, pieceCount: -25.0, linesCleared: 5.0, holes: -2.0 };

            return {
                expertDna: {
                    'GENERALIST': { networkDNA: null, weights: generalistWeights, persistence: 5 },
                    'T_SPIN': { networkDNA: null, weights: tSpinWeights, persistence: 4 },
                    'COMBO': { networkDNA: null, weights: comboWeights, persistence: 4 },
                    'DOWNSTACK': { networkDNA: null, weights: downstackWeights, persistence: 3 },
                    'ALL_CLEAR': { networkDNA: null, weights: allClearWeights, persistence: 3 }
                }
            };
        }

        // --- EVOLVABLE PERSISTENCE: Add mutation logic for the persistence value ---
        mutateExperts() {
            const mutationRate = parseFloat(document.getElementById("mutation-rate").value);
            const mutationAmount = parseFloat(document.getElementById("mutation-amount").value);
            for(const expert of this.expertTypes) {
                const expertDNA = this.expertDNA.expertDna[expert];
                if (expertDNA) {
                    // Mutate weights
                    if (expertDNA.weights) {
                        for(const weight in expertDNA.weights) {
                            if(Math.random() < mutationRate) {
                                expertDNA.weights[weight] += (Math.random() * 2 - 1) * mutationAmount * 0.2;
                            }
                        }
                    }
                    // Mutate persistence
                    if (expertDNA.persistence !== undefined && Math.random() < mutationRate) {
                         expertDNA.persistence += Math.round((Math.random() * 2 - 1) * 2); // Change by -2, -1, 0, 1, or 2
                         expertDNA.persistence = Math.max(1, Math.min(50, expertDNA.persistence)); // Clamp between 1 and 50
                    }
                }
                // Mutate network
                Network.mutate(this.expertBrains[expert], mutationRate, mutationAmount);
            }
        }

        getDNA() {
            const currentExpertDNA = JSON.parse(JSON.stringify(this.expertDNA));
            for(const expert of this.expertTypes) if(this.expertBrains[expert]) currentExpertDNA.expertDna[expert].networkDNA = Network.getDNA(this.expertBrains[expert]);
            const currentGatingDNA = JSON.parse(JSON.stringify(this.gatingDNA));
            currentGatingDNA.gatingNetworkDNA = this.gatingNetwork.getDNA();
            return { expertDNA: currentExpertDNA, gatingDNA: currentGatingDNA };
        }

        calculateFitness(game) {
            let fitness = game.score;
            fitness += Math.pow(game.maxCombo, 2) * 100;
            fitness += game.tSpins * 5000;
            fitness += game.tetrisesCleared * 2000;
            const survivalTime = (Date.now() - game.startTime) / 1000;
            fitness += survivalTime * 50;
            if (game.linesCleared < 5) {
                fitness *= 0.1;
            }
            if (game.linesCleared === 0) fitness = 1;
            return fitness > 0 ? fitness : 1;
        }
        
        start() { this.stop(); if (this.game.isRunning) { this.isThinking = false; this.think(); } }
        stop() { if(this.thinkTimeout) clearTimeout(this.thinkTimeout); this.isThinking = false; }

        // --- EVOLVABLE PERSISTENCE: Use value from DNA ---
        chooseNewExpert() {
            const explorationRate = parseFloat(document.getElementById('action-exploration-rate').value);
            const qValues = this.gatingNetwork.feedForward(this.game.grid);
            const biasedQValues = qValues.map((q, i) => q + (this.gatingDNA.exploration_biases[i] || 0));
            const chosenIndex = Math.random() < explorationRate ? Math.floor(Math.random() * this.expertTypes.length) : biasedQValues.indexOf(Math.max(...biasedQValues));
            this.currentExpert = this.expertTypes[chosenIndex];
            this.expertStepsRemaining = this.expertDNA.expertDna[this.currentExpert].persistence;
        }
        
        // --- EVOLVABLE PERSISTENCE: Use value from DNA ---
        forceRandomExpertSwitch() {
            const possibleExperts = this.expertTypes.filter(exp => exp !== this.currentExpert);
            if (possibleExperts.length > 0) {
                const newExpert = possibleExperts[Math.floor(Math.random() * possibleExperts.length)];
                this.currentExpert = newExpert;
                this.expertStepsRemaining = this.expertDNA.expertDna[this.currentExpert].persistence;
                console.log(`Agent ${this.game.id} FORCED SWITCH to ${this.currentExpert}`);
            }
        }

        async think() {
            if (this.isThinking || !this.game.isRunning || this.game.isGameOver || !this.game.activePiece) {
                if (this.game.isGameOver) this.stop();
                return;
            }
            this.isThinking = true;

            try {
                const piecesPlaced = this.game.piecesPlaced;

                if (piecesPlaced < 35) {
                    this.currentExpert = 'GENERALIST';
                    this.expertStepsRemaining = 35 - piecesPlaced;
                } else if (!this.hasMadeFirstSwitch) {
                    this.forceRandomExpertSwitch();
                    this.hasMadeFirstSwitch = true;
                } else {
                    if (this.expertStepsRemaining <= 0) {
                        this.chooseNewExpert();
                    }
                }

                if (this.expertStepsRemaining > 0) {
                    this.expertStepsRemaining--;
                }

                let chosenSequence = null, useHold = false;
                
                const beamCurrent = this.beamSearch(this.game.grid, [this.game.activePiece.type, ...this.game.pieceQueue], this.game.combo, this.game.b2b);
                let bestOverallScore = beamCurrent[0]?.score ?? -Infinity;
                
                if (this.game.canHold) {
                    const piecesAfterHold = this.game.holdPiece ? [this.game.holdPiece.type, ...this.game.pieceQueue] : this.game.pieceQueue.slice(1);
                    if (piecesAfterHold.length > 0) {
                        const beamHold = this.beamSearch(this.game.grid, piecesAfterHold, this.game.combo, this.game.b2b);
                        if ((beamHold[0]?.score ?? -Infinity) > bestOverallScore) useHold = true;
                    }
                }
                
                let targetBeam = useHold ? this.beamSearch(this.game.grid, this.game.holdPiece ? [this.game.holdPiece.type, ...this.game.pieceQueue] : this.game.pieceQueue.slice(1), this.game.combo, this.game.b2b) : beamCurrent;
                if (targetBeam.length > 0) chosenSequence = targetBeam[0];

                if (this.game.isGameOver) { this.isThinking = false; this.stop(); return; }

                if (useHold) { await this.game.hold(); } 
                else if (chosenSequence?.moveSequence.length > 0 && this.game.activePiece) { await this.executeMove(chosenSequence.moveSequence[0]); } 
                else if (this.game.activePiece) { this.game.hardDrop(); }

                this.previousFeatures = this.getBoardFeatures(this.game.grid);

            } finally {
                this.isThinking = false;
                if(!this.game.isGameOver && this.game.isRunning) {
                    const speed = parseFloat(document.getElementById('game-speed')?.value || 500);
                    const thinkDelay = 1000 - speed;
                    if (thinkDelay > 0) this.thinkTimeout = setTimeout(() => this.think(), thinkDelay);
                    else requestAnimationFrame(() => this.think());
                }
            }
        }
        
        beamSearch(initialGrid, pieceQueue, initialCombo, initialB2B) {
            const lookaheadDepth = parseInt(document.getElementById('lookahead-depth').value, 10);
            const beamWidth = parseInt(document.getElementById('beam-width').value, 10);
            const discountFactor = parseFloat(document.getElementById('discount-factor').value);
            let beam = [{ grid: initialGrid, combo: initialCombo, b2b: initialB2B, score: this.evaluateBoard(initialGrid).totalScore, moveSequence: [] }];

            for (let depth = 0; depth < lookaheadDepth; depth++) {
                if (!pieceQueue[depth]) break;
                const pieceType = pieceQueue[depth];
                const allNextStates = [];
                for (const node of beam) {
                    const possiblePlacements = this.calculatePossiblePlacements(node.grid, pieceType);
                    for (const placement of possiblePlacements) {
                        const reward = this.getImmediateReward(placement, node.combo, node.b2b);
                        const { totalScore: stateValue } = this.evaluateBoard(placement.grid);
                        const totalScore = reward + (stateValue * discountFactor);
                        allNextStates.push({ grid: placement.grid, combo: placement.nextCombo, b2b: placement.nextB2B, score: totalScore, moveSequence: [...node.moveSequence, placement] });
                    }
                }
                if (allNextStates.length === 0) break;
                allNextStates.sort((a, b) => b.score - a.score);
                beam = allNextStates.slice(0, beamWidth);
            }
            return beam;
        }
        
        getImmediateReward(placement, currentCombo, currentB2B) {
            const { linesCleared, isSpin, finesse, pieceType } = placement;
            let score = 0;
            const expertWeights = this.expertDNA.expertDna[this.currentExpert].weights;

            if (isSpin && linesCleared > 0) score += (expertWeights.spinExecutionBonus || 20) * 100 * linesCleared;
            else if (linesCleared === 4) score += (expertWeights.tetrisBonus || 8) * 100;
            else if (linesCleared > 0) score += (expertWeights.linesCleared || 1) * 100 * Math.pow(linesCleared, 2);
            
            if (currentB2B > 0 && (linesCleared >= 4 || (isSpin && linesCleared > 0))) score += (expertWeights.b2b || 1) * 50 * currentB2B;
            if (linesCleared > 0) score += (expertWeights.combo || 1) * 50 * currentCombo;
            
            score += finesse * (expertWeights.finessePenalty || -0.2);
            return score;
        }
        
       getBoardFeatures(grid, returnAsArray = false) {
            const columnHeights = new Array(COLS).fill(0);
            let aggregateHeight = 0; let maxHeight = 0;
            for (let c = 0; c < COLS; c++) {
                for (let r = 0; r < grid.length; r++) {
                    if (grid[r][c] !== 0) {
                        const height = (ROWS + HIDDEN_ROWS) - r;
                        columnHeights[c] = height;
                        break; 
                    }
                }
                aggregateHeight += columnHeights[c];
                if (columnHeights[c] > maxHeight) maxHeight = columnHeights[c];
            }

            let holes = 0; let coveredHoles = 0; let overhangs = 0;
            for (let c = 0; c < COLS; c++) {
                let colHasBlock = false;
                for (let r = 0; r < grid.length; r++) {
                    if (grid[r][c] !== 0) { 
                        colHasBlock = true; 
                    } else if (colHasBlock) {
                        holes++;
                        let aboveIsCovered = false;
                        for(let r2 = r - 1; r2 >= 0; r2--) {
                           if(grid[r2][c] !== 0) {
                               aboveIsCovered = true;
                               break;
                           }
                        }
                        if(aboveIsCovered) coveredHoles++;
                    }
                }
                for (let r = 1; r < grid.length; r++) {
                     if (grid[r][c] === 0 && grid[r-1][c] !== 0) {
                        overhangs++;
                     }
                }
            }
            
            let bumpiness = 0;
            for (let i = 0; i < COLS - 1; i++) bumpiness += Math.abs(columnHeights[i] - columnHeights[i + 1]);
            
            let spinOpportunities = 0;
            for (let r = 1; r < ROWS + HIDDEN_ROWS - 1; r++) {
                for (let c = 0; c < COLS; c++) {
                    const isHole = grid[r][c] === 0, isUpSolid = grid[r-1]?.[c] !== 0;
                    if(isHole && isUpSolid) {
                        const isLeftSolid = c > 0 ? grid[r][c-1] !== 0 : true;
                        const isRightSolid = c < COLS - 1 ? grid[r][c+1] !== 0 : true;
                        if(isLeftSolid && isRightSolid) spinOpportunities++;
                        else if(isLeftSolid || isRightSolid) spinOpportunities += 0.5;
                    }
                }
            }
            
            let wells = 0;
            for (let i = 0; i < COLS; i++) {
                const leftHeight = (i === 0) ? (ROWS + HIDDEN_ROWS) : columnHeights[i - 1];
                const rightHeight = (i === COLS - 1) ? (ROWS + HIDDEN_ROWS) : columnHeights[i + 1];
                const wellDepth = Math.min(leftHeight, rightHeight) - columnHeights[i];
                if(wellDepth > 0) wells += wellDepth;
            }

            let deepestWell = 0;
            for (let i = 0; i < COLS; i++) {
                 let wellDepth = 0;
                 const leftHeight = (i > 0) ? columnHeights[i-1] : (ROWS + HIDDEN_ROWS);
                 const rightHeight = (i < COLS - 1) ? columnHeights[i+1] : (ROWS + HIDDEN_ROWS);
                 if (columnHeights[i] < leftHeight && columnHeights[i] < rightHeight) {
                    wellDepth = Math.min(leftHeight, rightHeight) - columnHeights[i];
                 }
                 if(wellDepth > deepestWell) deepestWell = wellDepth;
            }


            let rowTransitions = 0, columnTransitions = 0;
            for (let r = 0; r < ROWS + HIDDEN_ROWS; r++) for (let c = 0; c < COLS; c++) {
                const current = grid[r]?.[c] > 0, right = grid[r]?.[c + 1] > 0, down = grid[r + 1]?.[c] > 0;
                if (c < COLS - 1 && current !== right) rowTransitions++;
                if (r < ROWS + HIDDEN_ROWS - 1 && current !== down) columnTransitions++;
            }
            
            let pieceCount = 0;
            for (let r = 0; r < grid.length; r++) for (let c = 0; c < COLS; c++) if (grid[r][c] !== 0) pieceCount++;

            let imminentClears = 0;
            for(let r = 0; r < grid.length; r++) {
                let filledCount = 0;
                for(let c = 0; c < COLS; c++) if (grid[r][c] !== 0) filledCount++;
                if (filledCount >= 8 && filledCount < COLS) imminentClears += filledCount / COLS;
            }
            
            let dangerZonePenalty = maxHeight > (ROWS * 0.75) ? (maxHeight - (ROWS * 0.75))**2 : 0;
            let heightStandardDeviation = 0;
            if (aggregateHeight > 0) {
                const meanHeight = aggregateHeight / COLS;
                let variance = columnHeights.reduce((sum, h) => sum + Math.pow(h - meanHeight, 2), 0) / COLS;
                heightStandardDeviation = Math.sqrt(variance);
            }
            
            let spirePenalty = 0;
            for(let c = 0; c < COLS; c++) {
                const leftHeight = c > 0 ? columnHeights[c-1] : maxHeight;
                const rightHeight = c < COLS-1 ? columnHeights[c+1] : maxHeight;
                const avgNeighborHeight = (leftHeight + rightHeight) / 2;
                const spireHeight = columnHeights[c] - avgNeighborHeight;
                if (spireHeight > 3) spirePenalty += spireHeight;
            }

            const features = { aggregateHeight, maxHeight, holes, coveredHoles, bumpiness, wells, rowTransitions, columnTransitions, spinOpportunities, pieceCount, overhangs, deepestWell, imminentClears, dangerZonePenalty, heightStandardDeviation, spirePenalty };
            return returnAsArray ? Object.values(features) : features;
        }

        evaluateBoard(grid) {
            const features = this.getBoardFeatures(grid);
            const expertWeights = this.expertDNA.expertDna[this.currentExpert].weights;
            let totalScore = 0;

            const curriculumGenerations = parseInt(document.getElementById('curriculum-generations').value, 10);
            if (this.generation < curriculumGenerations) {
                for (const key in features) {
                    if (expertWeights[key] !== undefined) {
                        totalScore += (expertWeights[key] || 0) * features[key];
                    }
                }
            } else {
                const featureVector = Object.values(features);
                const expertBrain = this.expertBrains[this.currentExpert];
                const adjustments = Network.feedForward(featureVector, expertBrain);
                
                const weightKeys = Object.keys(expertWeights);
                for(let i=0; i < weightKeys.length; i++) {
                    const key = weightKeys[i];
                    if (features[key] === undefined) continue;
                    const base = expertWeights[key] || 0;
                    const adjustment = (adjustments[i] || 0);
                    totalScore += (base + adjustment) * features[key];
                }
            }
            return { totalScore, heuristicValues: features };
        }

        updateAgentDisplay() {
            const displayEl = this.game.dnaDisplayEl;
            if(displayEl) {
                 displayEl.innerHTML = `
                    <h4 class="font-bold text-sm mb-1">Agent Info:</h4>
                    <p>Expert: <span class="font-bold text-teal-300">${this.currentExpert}</span></p>
                    <p>Steps Left: <span class="font-bold">${this.expertStepsRemaining}</span></p>
                 `;
            }
        }

        calculatePossiblePlacements(grid, pieceType) {
            const placements = [];
            const spawnX = (pieceType === "O" ? 4 : 3), spawnY = (pieceType === "I" ? 17 : 18);
            const queue = [{ x: spawnX, y: spawnY, rotation: 0, shape: SHAPES[pieceType][0], finesse: 0, path: [] }];
            const visitedStates = new Set();
            visitedStates.add(`${spawnX},${spawnY},0`);
            const visitedPlacements = new Set();

            while (queue.length > 0) {
                const currentPiece = queue.shift();
                let finalY = currentPiece.y;
                while (!this.game.checkCollision(currentPiece.shape, currentPiece.x, finalY + 1, grid)) finalY++;

                const placementKey = `${currentPiece.x},${finalY},${currentPiece.rotation}`;
                if (!visitedPlacements.has(placementKey)) {
                    visitedPlacements.add(placementKey);
                    
                    const tempGrid = grid.map((row) => [...row]);
                    currentPiece.shape.forEach((row, y) => row.forEach((val, x) => { if (val !== 0 && tempGrid[finalY + y]) tempGrid[finalY + y][currentPiece.x + x] = val; }));
                    let linesCleared = 0;
                    for (let y = 0; y < tempGrid.length; y++) if (tempGrid[y].every((cell) => cell !== 0)) linesCleared++;
                    const { isSpin, isMini } = this.game.checkSpin({ type: pieceType, x: currentPiece.x, y: finalY, rotation: currentPiece.rotation }, tempGrid);
                    const nextCombo = linesCleared > 0 ? (this.game.combo || 0) + 1 : 0;
                    const isDifficult = linesCleared >= 4 || isSpin;
                    const nextB2B = isDifficult ? (this.game.b2b || 0) + 1 : 0;
                    placements.push({ rotation: currentPiece.rotation, x: currentPiece.x, grid: tempGrid, linesCleared, isSpin, isMini, nextCombo, finesse: currentPiece.finesse, isDifficult, nextB2B, pieceType, path: currentPiece.path });
                }

                const moves = [ { name:'L', dx: -1, dy: 0, dr: 0 }, { name:'R', dx: 1, dy: 0, dr: 0 }, { name:'D', dx: 0, dy: 1, dr: 0 }, { name:'CW', dx: 0, dy: 0, dr: 1 }, { name:'CCW', dx: 0, dy: 0, dr: -1 } ];
                for (const move of moves) {
                    if (pieceType === 'O' && move.dr !== 0) continue;
                    let nextPiece = { ...currentPiece, path: [...currentPiece.path, move.name] };
                    nextPiece.x += move.dx; nextPiece.y += move.dy;
                    if (move.dr !== 0) {
                        nextPiece.rotation = (nextPiece.rotation + move.dr + 4) % 4;
                        nextPiece.shape = SHAPES[pieceType][nextPiece.rotation];
                    }
                    const stateKey = `${nextPiece.x},${nextPiece.y},${nextPiece.rotation}`;
                    if (!this.game.checkCollision(nextPiece.shape, nextPiece.x, nextPiece.y, grid) && !visitedStates.has(stateKey)) {
                        nextPiece.finesse++;
                        visitedStates.add(stateKey);
                        queue.push(nextPiece);
                    }
                }
            }
            return placements;
        }
        
        async executeMove(move) {
            if (this.game.isGameOver || !this.game.activePiece) return;
            const speed = parseFloat(document.getElementById('game-speed')?.value || 500);
            const moveDelay = speed < 950 ? (1000 - speed) / 20 : 0;
            
            for (const action of move.path) {
                if (!this.game.activePiece) break;
                switch (action) {
                    case 'L': this.game.move(-1); break;
                    case 'R': this.game.move(1); break;
                    case 'D': this.game.drop(true); break;
                    case 'CW': this.game.rotate(1); break;
                    case 'CCW': this.game.rotate(-1); break;
                }
                if (moveDelay > 0) await new Promise(res => setTimeout(res, moveDelay));
            }
            
            if (this.game.activePiece) this.game.hardDrop();
        }
    }

    // --- MAIN SCRIPT ---
    let gameInstances = []; let agents = []; let humanPlayerKeyListeners = null;
    let generationCounter = 0;
    let performanceHistory = { labels: [], topScores: [], avgScores: [] };
    let performanceChart;
    
    function createInstanceElement(id) { const w = document.createElement('div'); w.className = 'instance-wrapper bg-gray-800/50 p-4 rounded-lg shadow-md'; w.id = `instance-wrapper-${id}`; return w; }
    
    function updateGeneration(isNew) {
        if(isNew) {
             generationCounter = 0;
             performanceHistory = { labels: [], topScores: [], avgScores: [] };
             if(performanceChart) performanceChart.destroy();
             initializeChart();
        } else {
            const fitnessScores = agents.map(a => a.finalFitness || 0).filter(f => f !== undefined && f !== null);
            if(fitnessScores.length > 0) {
                const topScore = Math.max(...fitnessScores);
                const avgScore = fitnessScores.reduce((a, b) => a + b, 0) / fitnessScores.length;
                performanceHistory.labels.push(generationCounter);
                performanceHistory.topScores.push(topScore);
                performanceHistory.avgScores.push(avgScore);
                if(performanceChart) performanceChart.update();
            }
        }
        generationCounter++;
        document.getElementById('generation-display').textContent = generationCounter;
    }
    
    function generateInstances(parentADNA = null, parentBDNA = null, globalGatingDNA = null, isNewPopulation = true) {
        if(!isNewPopulation) updateGeneration(false);
        else updateGeneration(true);
        
        const instancesContainer = document.getElementById('game-instances-container');
        const numInstancesInput = document.getElementById('num-instances');
        const seedDisplay = document.getElementById('seed-display');
        stopAll();
        instancesContainer.innerHTML = '';
        gameInstances = [];
        agents = [];
        if (humanPlayerKeyListeners) {
            document.removeEventListener('keydown', humanPlayerKeyListeners.down);
            document.removeEventListener('keyup', humanPlayerKeyListeners.up);
        }
        const seed = Date.now();
        seedDisplay.textContent = `Current Seed: ${seed}`;
        const count = parseInt(numInstancesInput.value, 10);
        const includeHuman = document.getElementById('human-player-checkbox').checked;

        for (let i = 1; i <= count; i++) {
            const instanceEl = createInstanceElement(i);
            instancesContainer.appendChild(instanceEl);
            const game = new TetrisGame(instanceEl, i, seed);
            gameInstances.push(game);

            if (!includeHuman || i > 1) {
                let childExpertDNA;
                let shouldMutate = true;

                if(isNewPopulation || !parentADNA) {
                    childExpertDNA = null; 
                } else {
                    if (i === 1) { 
                         childExpertDNA = parentADNA;
                         shouldMutate = false; 
                    } else if (i === 2 && parentBDNA) {
                         childExpertDNA = parentBDNA;
                    } else {
                        childExpertDNA = crossover(parentADNA, parentBDNA || parentADNA);
                    }
                }
                let agent = new Agent(game, childExpertDNA, globalGatingDNA, shouldMutate, generationCounter);
                agents.push(agent);
                game.agent = agent; 
            }
        }
        if (includeHuman && gameInstances.length > 0) {
            const humanPlayer = gameInstances[0];
            humanPlayerKeyListeners = { down: (e) => humanPlayer.handleKeyDown(e), up: (e) => humanPlayer.handleKeyUp(e) };
            document.addEventListener('keydown', humanPlayerKeyListeners.down);
            document.addEventListener('keyup', humanPlayerKeyListeners.up);
            document.querySelector('#instance-wrapper-1 h2').textContent += " (Player)";
        }
    }

    function startAll() { gameInstances.forEach(game => game.start()); if (document.getElementById('ai-enabled-checkbox').checked) { agents.forEach(agent => agent.start()); } }
    function stopAll() { gameInstances.forEach(game => game.stop()); agents.forEach(agent => agent.stop()); }
    
    function evolveAndFederate() {
        if (agents.length === 0) return;

        let totalFitness = 0;
        agents.forEach(agent => {
            agent.finalFitness = agent.calculateFitness(agent.game);
            totalFitness += agent.finalFitness;
        });

        if (totalFitness === 0) {
            console.log("Total fitness is 0. Resetting with a new random population.");
            generateInstances(null, null, null, true);
            setTimeout(startAll, 500);
            return;
        }

        const firstAgent = agents[0];
        const newGlobalGatingDNA = firstAgent.getInitialGatingDNA();
        newGlobalGatingDNA.gatingNetworkDNA = firstAgent.gatingNetwork.getDNA();
        for (const streamKey in newGlobalGatingDNA.gatingNetworkDNA) {
            newGlobalGatingDNA.gatingNetworkDNA[streamKey].layers.forEach(layer => {
                if(layer.weights) layer.weights.fill(0);
                if(layer.biases) layer.biases.fill(0);
            });
        }
        
        agents.forEach(agent => {
            const weight = agent.finalFitness / totalFitness;
            const fullDNA = agent.getDNA();
            const localGatingDNA = fullDNA.gatingDNA.gatingNetworkDNA;
            for(let i = 0; i < newGlobalGatingDNA.exploration_biases.length; i++) newGlobalGatingDNA.exploration_biases[i] += (fullDNA.gatingDNA.exploration_biases[i] || 0) * weight;
            for(const streamKey in localGatingDNA) {
                for(let l=0; l < localGatingDNA[streamKey].layers.length; l++){
                    const localLayer = localGatingDNA[streamKey].layers[l];
                    const globalLayer = newGlobalGatingDNA.gatingNetworkDNA[streamKey].layers[l];
                    if(localLayer.weights) for (let i = 0; i < localLayer.weights.length; i++) globalLayer.weights[i] += (localLayer.weights[i] || 0) * weight;
                    if(localLayer.biases) for (let i = 0; i < localLayer.biases.length; i++) globalLayer.biases[i] += (localLayer.biases[i] || 0) * weight;
                }
            }
        });
        
        console.log("Finding top parents for expert crossover...");
        agents.sort((a, b) => b.finalFitness - a.finalFitness);
        const parentA = agents[0];
        const parentB = agents.length > 1 ? agents[1] : agents[0];
        
        const parentADNA = parentA.getDNA().expertDNA;
        const parentBDNA = parentB.getDNA().expertDNA;
        
        console.log(`Top parents: Agent ${parentA.game.id} (Fitness: ${parentA.finalFitness}) & Agent ${parentB.game.id} (Fitness: ${parentB.finalFitness})`);
        
        generateInstances(parentADNA, parentBDNA, newGlobalGatingDNA, false);
        setTimeout(startAll, 500);
    }
    
    function crossover(dnaA, dnaB) {
        const childDNA = JSON.parse(JSON.stringify(dnaA));
        if (!dnaB) return childDNA;
        const experts = Object.keys(childDNA.expertDna);
        for(const expert of experts) {
            if(dnaB.expertDna[expert] && Math.random() < 0.5) {
                childDNA.expertDna[expert] = dnaB.expertDna[expert];
            }
        }
        return childDNA;
    }

    function checkAllGameOver() {
        const agentGames = gameInstances.filter(g => g.agent);
        if (agentGames.length > 0 && agentGames.every(g => g.isGameOver)) {
            evolveAndFederate();
        }
    }

    function extractBestAgentDNA() {
        if (agents.length === 0) { return; }
        const dnaDisplay = document.getElementById('dna-display');
        const parentInput = document.getElementById('parent-dna-input');
        const bestAgent = agents.reduce((best, current) => ((current.finalFitness || 0) > (best.finalFitness || 0) ? current : best), agents[0]);
        if (bestAgent) {
            const dnaString = JSON.stringify(bestAgent.getDNA(), null, 2);
            dnaDisplay.textContent = dnaString;
            parentInput.value = dnaString;
            dnaDisplay.classList.remove('hidden');
        }
    }
    
    function generateFromParent() {
        const parentInput = document.getElementById('parent-dna-input');
        try {
            if (!parentInput.value) { alert("Parent DNA input is empty."); return; }
            const parentFullDNA = JSON.parse(parentInput.value);
            generateInstances(parentFullDNA.expertDNA, parentFullDNA.expertDNA, parentFullDNA.gatingDNA, false);
        } catch (e) {
            alert("Invalid JSON in parent DNA input."); console.error("Error parsing parent DNA:", e);
        }
    }

    function initializeChart() {
         const ctx = document.getElementById('performance-chart').getContext('2d');
         performanceChart = new Chart(ctx, {
            type: 'line',
            data: { labels: performanceHistory.labels, datasets: [{ label: 'Top Fitness', data: performanceHistory.topScores, borderColor: 'rgba(75, 192, 192, 1)', tension: 0.1 }, { label: 'Average Fitness', data: performanceHistory.avgScores, borderColor: 'rgba(255, 99, 132, 1)', tension: 0.1 }] },
            options: { scales: { y: { beginAtZero: true } } }
         });
    }

    // --- EVENT LISTENERS ---
    function setupSlider(sliderId, valueId, isFloat = false) {
        const slider = document.getElementById(sliderId);
        const valueEl = document.getElementById(valueId);
        slider.oninput = () => { valueEl.textContent = isFloat ? parseFloat(slider.value).toFixed(2) : slider.value; };
    }
    setupSlider('learning-rate', 'learning-rate-value', true);
    setupSlider('action-exploration-rate', 'action-exploration-rate-value', true);
    setupSlider('lookahead-depth', 'lookahead-depth-value');
    setupSlider('beam-width', 'beam-width-value');
    setupSlider('discount-factor', 'discount-factor-value', true);
    setupSlider('mutation-rate', 'mutation-rate-value', true);
    setupSlider('mutation-amount', 'mutation-amount-value', true);
    setupSlider('topology-mutation-rate', 'topology-mutation-rate-value', true);
    
    document.getElementById('game-speed').oninput = function() {
        const speed = parseInt(this.value, 10);
        const speedValue = document.querySelector('#game-speed-value') || {};
        if (speed < 10) speedValue.textContent = 'Paused';
        else if (speed < 300) speedValue.textContent = 'Slow';
        else if (speed < 700) speedValue.textContent = 'Normal';
        else if (speed < 990) speedValue.textContent = 'Fast';
        else speedValue.textContent = 'Instant';
    };
    
    document.getElementById('toggle-chart-btn').addEventListener('click', () => {
        document.getElementById('chart-wrapper').classList.toggle('hidden');
    });
    
    document.getElementById('start-all-btn').addEventListener('click', startAll);
    document.getElementById('stop-all-btn').addEventListener('click', stopAll);
    document.getElementById('generate-instances-btn').addEventListener('click', () => generateInstances(null, null, null, true));
    document.getElementById('extract-dna-btn').addEventListener('click', extractBestAgentDNA);
    document.getElementById('permutate-btn').addEventListener('click', generateFromParent);
    
    window.onload = () => {
        generateInstances(null, null, null, true);
        initializeChart();
    };
    </script>
</body>
</html>